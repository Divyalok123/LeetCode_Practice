/*
https://leetcode.com/problems/minimize-malware-spread-ii/
*/

#include <iostream>
#include <unordered_map>
#include <vector>
#include <algorithm>
using namespace std;

//union-find O(n^2)
class Solution {
public:
    
    vector<int> p, size;
    
    int find(int a) {
        return a == p[a] ? a : p[a] = find(p[a]);
    }
    
    void un(int a, int b) {
        int pa = find(a), pb = find(b);
        
        if(pa != pb) {
            int sa = size[pa], sb = size[pb];
            if(sa < sb)
                swap(pa, pb);
            p[pb] = pa;
            size[pa] += size[pb];
        }
    }
    
    int getsize(int a) {
        return size[find(a)];
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        
        size.assign(n, 1);
        p.resize(n);
        iota(p.begin(), p.end(), 0);
        
        vector<bool> check(n, 0);
        
        for(int& i: initial)
            check[i] = 1;
        
        for(int i = 0; i < n; i++) {
            if(check[i] == 0)
            for(int j = i+1; j < n; j++) {
                if(check[j] == 0 && graph[i][j])
                    un(i, j);
            }
        }            
        
        vector<unordered_set<int>> um(n);
        vector<int> count(n);
        
        for(int& in: initial) {
            unordered_set<int>& s = um[in];
            
            for(int i = 0; i < n; i++) {
                if(check[i] == 0 && graph[i][in])
                    s.insert(find(i));
            }
            
            for(const int& i: s) 
                count[i]++;
        }
        
        int ans = -1, ind = -1;
        for(int& key: initial) {
            unordered_set<int>& sett = um[key];
            int thiscount = 0;
            for(const int& i: sett) {
                if(count[i] == 1) {
                    thiscount += getsize(i);
                }
            }

            if(thiscount > ans || (thiscount == ans && key < ind)) {
                ans = thiscount;
                ind = key;
            }
        }
        
        return ind;
    }
};

//dfs - O(n^2)
class Solution {
public:
    
    void dfs(vector<vector<int>>& g, int i, int main, vector<bool>& vis, vector<bool>& check, vector<vector<int>>& store) {
        vis[i] = 1;
        store[i].push_back(main);
        
        for(int& j: g[i]) {
            if(!vis[j] && !check[j])
                dfs(g, j, main, vis, check, store);
        }
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        
        vector<vector<int>> g(n);
        
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++)
                if(graph[i][j]) {
                    g[i].push_back(j);
                    g[j].push_back(i);
                }
        }
        
        vector<bool> check(n);
        vector<vector<int>> store(n);
        
        for(int i = 0; i < initial.size(); i++)
            check[initial[i]] = 1;
        
        for(int i = 0; i < initial.size(); i++) {
            vector<bool> vis(n);
            dfs(g, initial[i], initial[i], vis, check, store);
        }
        
        unordered_map<int, int> um;
        for(int i = 0; i < n; i++) {
            if(!check[i] && store[i].size() == 1) {
                um[store[i][0]]++;
            }
        }        
        
        int ind = -1, ans = -1;
        for(int& i: initial) {
            if(um[i] > ans || (um[i] == ans && i < ind)) {
                ans = um[i];
                ind = i;
            }
        }
        
        return ind;
    }
};